#!/usr/bin/env node

const prompts = require('prompts');
const languages = require('./Languages');
const { managers } = require('./PackageManagers');
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Fonction pour créer le projet
async function createProject(projectName, packageManager, bundler, useTypeScript, framework, lang, stylingLibrary) {
  const pm = managers[packageManager];
  const typeScriptMessage = useTypeScript ? lang.withTypeScript : lang.withoutTypeScript;
  
  // Transformer le nom du projet en minuscules pour Next.js
  const formattedProjectName = bundler === 'next' ? projectName.toLowerCase() : projectName;
  
  console.log(lang.creatingProject.replace('{projectName}', formattedProjectName)
                                  .replace('{packageManager}', packageManager)
                                  .replace('{bundler}', bundler)
                                  .replace('{withTypeScript}', typeScriptMessage));
  
  let creationCommand;
  switch(bundler) {
    case 'vite':
      const template = `${framework}${useTypeScript ? '-ts' : ''}`;
      creationCommand = `${pm.createVite} ${formattedProjectName} --template ${template}`;
      break;
    case 'cra':
      creationCommand = `${pm.createReactApp} ${formattedProjectName}${useTypeScript ? ' --template typescript' : ''}`;
      break;
    case 'next':
      creationCommand = `${pm.createNext} ${formattedProjectName} --js ${useTypeScript ? '--typescript' : ''} --eslint --no-tailwind --no-src-dir --app --no-import-alias`;
      break;
    default:
      throw new Error(lang.invalidBundler);
  }

  try {
    console.log(`${lang.executingCommand} ${creationCommand}`);
    execSync(creationCommand, { stdio: 'inherit' });

    // Changer le répertoire de travail vers le nouveau projet
    process.chdir(projectName);
    // Installer les dépendances si nécessaire
    if (packageManager !== 'npm' && packageManager !== 'bun') {
      console.log(lang.installingDependencies);
      execSync(pm.install, { stdio: 'inherit' });
    }

    // Ajouter un script de démarrage personnalisé au package.json
    const packageJsonPath = path.join(process.cwd(), 'package.json');
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    packageJson.scripts.start = pm.run + ' start';
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));

    // Initialisation finale du projet
    console.log(lang.finalizingProjectSetup);
    execSync(`${pm.install}`, { stdio: 'inherit' });

    console.log(lang.projectCreated.replace('{projectName}', projectName));
    console.log(lang.startCommand.replace('{command}', `cd ${projectName} && ${pm.run} start`));
  } catch (error) {
    console.error(lang.error, error);
  }
}

// Fonction pour choisir la langue
async function chooseLanguage() {
  const languageChoice = await prompts({
    type: 'select',
    name: 'language',
    message: 'Choose your language / Choisissez votre langue :',
    choices: [
      { title: 'English', value: 'en' },
      { title: 'Français', value: 'fr' }
    ]
  });
  return languageChoice.language;
}

// Fonction principale
async function main() {
  let lang;
  let projectSummary = {};
  try {
    const language = await chooseLanguage();
    lang = languages[language];

    if (!lang || !lang.questions) {
      throw new Error('Language configuration is invalid');
    }

    console.log(lang.welcome);

    const allQuestions = [
      ...lang.questions,
      {
        type: (prev, values) => values.bundler === 'next' ? null : 'select',
        name: 'framework',
        message: lang.chooseFramework,
        choices: (prev, values) => {
          if (values.bundler === 'next') {
            return null; // Ne pas poser la question pour Next.js
          }
          return [
            { title: 'React', value: 'react' },
            { title: 'Vue', value: 'vue' },
            { title: 'Preact', value: 'preact' },
            { title: 'Lit', value: 'lit' },
            { title: 'Svelte', value: 'svelte' },
            { title: 'Solid', value: 'solid' },
            { title: 'Qwik', value: 'qwik' },
            { title: 'Vanilla', value: 'vanilla' }
          ];
        }
      },
      {
        type: 'select',
        name: 'useTypeScript',
        message: lang.useTypeScript,
        choices: [
          { title: lang.yes, value: true },
          { title: lang.no, value: false }
        ]
      },
      {
        type: 'select',
        name: 'initGit',
        message: lang.initGit,
        choices: [
          { title: lang.yes, value: true },
          { title: lang.no, value: false }
        ]
      },
      {
        type: 'select',
        name: 'stateManager',
        message: lang.chooseStateManager,
        choices: [
          { title: lang.none, value: 'none' },
          { title: 'Redux', value: 'redux' },
          { title: 'MobX', value: 'mobx' },
          { title: 'Recoil', value: 'recoil' },
          { title: 'Zustand', value: 'zustand' }
        ]
      },
      {
        type: 'select',
        name: 'stylingLibrary',
        message: lang.chooseStylingLibrary,
        choices: [
          { title: lang.none, value: 'none' },
          { title: 'Styled-components', value: 'styled-components' },
          { title: 'Emotion', value: 'emotion' },
          { title: 'Tailwind CSS', value: 'tailwind' },
          { title: 'SASS', value: 'sass' },
          { title: 'Bootstrap', value: 'bootstrap' },
          { title: 'Pico CSS', value: 'pico' }
        ]
      },
      {
        type: 'select',
        name: 'setupTests',
        message: lang.setupTests,
        choices: [
          { title: lang.yes, value: true },
          { title: lang.no, value: false }
        ]
      },
      {
        type: 'select',
        name: 'setupCI',
        message: lang.setupCI,
        choices: [
          { title: lang.yes, value: true },
          { title: lang.no, value: false }
        ]
      },
      {
        type: 'select',
        name: 'setupDocker',
        message: lang.setupDocker,
        choices: [
          { title: lang.yes, value: true },
          { title: lang.no, value: false }
        ]
      },
      {
        type: 'select',
        name: 'installReactRouter',
        message: lang.installReactRouter,
        choices: [
          { title: lang.yes, value: true },
          { title: lang.no, value: false }
        ]
      }
    ];

    const response = await prompts(allQuestions);

    projectSummary = {
      projectName: response.projectName,
      packageManager: response.packageManager,
      bundler: response.bundler,
      framework: response.bundler === 'next' ? 'React' : response.framework,
      useTypeScript: response.useTypeScript,
      stateManager: response.stateManager,
      stylingLibrary: response.stylingLibrary,
      initGit: response.initGit,
      setupTests: response.setupTests,
      setupCI: response.setupCI,
      setupDocker: response.setupDocker,
      installReactRouter: response.installReactRouter
    };

    await createProject(response.projectName, response.packageManager, response.bundler, response.useTypeScript, response.framework, lang, response.stylingLibrary);

    if (response.initGit) {
      await initializeGit(lang);
    }

    if (response.stateManager !== 'none') {
      await installStateManager(response.packageManager, response.stateManager, lang, response.projectName);
    }

    if (response.stylingLibrary !== 'none') {
      await installStylingLibrary(response.packageManager, response.stylingLibrary, lang);
    }

    // Afficher le récapitulatif
    console.log(lang.projectSummary);
    console.log(getProjectSummary(projectSummary, lang));

  } catch (error) {
    if (lang && lang.error) {
      console.error(lang.error, error);
    } else {
      console.error("An error occurred:", error);
    }
  }
}

function getProjectSummary(summary, lang) {
  let summaryLines = [
    lang.summaryTemplate
      .replace('{projectName}', summary.projectName)
      .replace('{packageManager}', summary.packageManager)
      .replace('{bundler}', summary.bundler)
      .replace('{framework}', summary.framework)
      .replace('{language}', summary.useTypeScript ? 'TypeScript' : 'JavaScript')
  ];

  if (summary.stateManager !== 'none') {
    summaryLines.push(lang.summaryStateManager.replace('{stateManager}', summary.stateManager));
  }

  if (summary.stylingLibrary !== 'none') {
    summaryLines.push(lang.summaryStylingLibrary.replace('{stylingLibrary}', summary.stylingLibrary));
  }

  let additionalFeatures = [];
  if (summary.initGit) additionalFeatures.push(lang.summaryGit);
  if (summary.setupTests) additionalFeatures.push(lang.summaryTests);
  if (summary.setupCI) additionalFeatures.push(lang.summaryCI);
  if (summary.setupDocker) additionalFeatures.push(lang.summaryDocker);
  if (summary.installReactRouter) additionalFeatures.push(lang.summaryReactRouter);

  if (additionalFeatures.length > 0) {
    summaryLines.push(lang.summaryAdditionalFeatures);
    additionalFeatures.forEach(feature => {
      summaryLines.push(feature);
    });
  }

  summaryLines.push('');  // Ligne vide pour séparer
  summaryLines.push(lang.startCommand.replace('{command}', `cd ${summary.projectName} && ${managers[summary.packageManager].run} start`));

  return summaryLines.join('\n');
}

// Fonction pour installer une bibliothèque de styles
async function installStylingLibrary(packageManager, stylingLibrary, lang) {
  const pm = managers[packageManager];
  let installCommand;

  switch(stylingLibrary) {
    case 'styled-components':
      installCommand = `${pm.install} styled-components`;
      break;
    case 'emotion':
      installCommand = `${pm.install} @emotion/react @emotion/styled`;
      break;
    case 'tailwind':
      installCommand = `${pm.install} -D tailwindcss postcss autoprefixer`;
      break;
    case 'sass':
      installCommand = `${pm.install} -D sass`;
      break;
    case 'bootstrap':
      installCommand = `${pm.install} bootstrap`;
      break;
    case 'pico':
      installCommand = `${pm.install} @picocss/pico`;
      break;
    default:
      return; // No styling library to install
  }

  console.log(lang.installingStylingLibrary.replace('{library}', stylingLibrary));
  execSync(installCommand, { stdio: 'inherit' });
}

// Fonction pour installer le gestionnaire d'état
async function installStateManager(packageManager, stateManager, lang, projectName) {
  const pm = managers[packageManager];
  let installCommand;

  switch(stateManager) {
    case 'redux':
      installCommand = `${pm.install} redux react-redux @reduxjs/toolkit`;
      break;
    case 'mobx':
      installCommand = `${pm.install} mobx mobx-react-lite`;
      break;
    case 'recoil':
      installCommand = `${pm.install} recoil`;
      break;
    case 'zustand':
      installCommand = `${pm.install} zustand`;
      break;
    default:
      return; // Pas de gestionnaire d'état à installer
  }

  console.log(lang.installingStateManager.replace('{stateManager}', stateManager));
  execSync(installCommand, { stdio: 'inherit' });

  // Création des fichiers et structures nécessaires
  const srcDir = path.join(process.cwd(), 'src');
  
  switch(stateManager) {
    case 'redux':
      const storeDir = path.join(srcDir, 'store');
      fs.mkdirSync(storeDir, { recursive: true });
      fs.writeFileSync(path.join(storeDir, 'index.js'), getReduxStoreContent());
      fs.writeFileSync(path.join(srcDir, 'App.js'), getReduxAppContent(projectName));
      break;
    case 'mobx':
      const storesDir = path.join(srcDir, 'stores');
      fs.mkdirSync(storesDir, { recursive: true });
      fs.writeFileSync(path.join(storesDir, 'counterStore.js'), getMobxStoreContent());
      fs.writeFileSync(path.join(srcDir, 'App.js'), getMobxAppContent(projectName));
      break;
    case 'recoil':
      fs.writeFileSync(path.join(srcDir, 'atoms.js'), getRecoilAtomsContent());
      fs.writeFileSync(path.join(srcDir, 'App.js'), getRecoilAppContent(projectName));
      break;
    case 'zustand':
      fs.writeFileSync(path.join(srcDir, 'store.js'), getZustandStoreContent());
      fs.writeFileSync(path.join(srcDir, 'App.js'), getZustandAppContent(projectName));
      break;
  }

  console.log(lang.stateManagerConfigured.replace('{stateManager}', stateManager));
}

// Fonctions pour générer le contenu des fichiers
function getReduxStoreContent() {
  return `
import { configureStore } from '@reduxjs/toolkit';

export const store = configureStore({
  reducer: {},
});
`;
}

function getReduxAppContent(projectName) {
  return `
import React from 'react';
import { Provider } from 'react-redux';
import { store } from './store';

function App() {
  return (
    <Provider store={store}>
      <div>
        <h1>${projectName}</h1>
        {/* Vos composants ici */}
      </div>
    </Provider>
  );
}

export default App;
`;
}

function getMobxStoreContent() {
  return `
import { makeAutoObservable } from "mobx"

class CounterStore {
  count = 0

  constructor() {
    makeAutoObservable(this)
  }

  increment() {
    this.count++
  }
}

export const counterStore = new CounterStore()
`;
}

function getMobxAppContent(projectName) {
  return `
import React from 'react';
import { observer } from "mobx-react-lite"
import { counterStore } from './stores/counterStore';

const App = observer(() => {
  return (
    <div>
      <h1>${projectName}</h1>
      <p>Count: {counterStore.count}</p>
      <button onClick={() => counterStore.increment()}>Increment</button>
    </div>
  );
})

export default App;
`;
}

function getRecoilAtomsContent() {
  return `
import { atom } from 'recoil';

export const countState = atom({
  key: 'countState',
  default: 0,
});
`;
}

function getRecoilAppContent(projectName) {
  return `
import React from 'react';
import { RecoilRoot, useRecoilState } from 'recoil';
import { countState } from './atoms';

function Counter() {
  const [count, setCount] = useRecoilState(countState);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

function App() {
  return (
    <RecoilRoot>
      <div>
        <h1>${projectName}</h1>
        <Counter />
      </div>
    </RecoilRoot>
  );
}

export default App;
`;
}

function getZustandStoreContent() {
  return `
import create from 'zustand';

export const useStore = create(set => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 })),
}));
`;
}

function getZustandAppContent(projectName) {
  return `
import React from 'react';
import { useStore } from './store';

function App() {
  const { count, increment } = useStore();
  return (
    <div>
      <h1>${projectName}</h1>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

export default App;
`;
}

// Fonction pour initialiser Git
async function initializeGit(lang) {
  try {
    console.log(lang.initializingGit);
    execSync('git init', { stdio: 'inherit' });
    execSync('git add .', { stdio: 'inherit' });
    execSync('git commit -m "Initial commit"', { stdio: 'inherit' });
    console.log(lang.gitInitialized);
  } catch (error) {
    console.error(lang.gitInitError, error);
  }
}

// Exécution du script
main();